---
title: "Report 20231024"
format: pdf
editor: visual
---

## Settings

Since random signal positions might caused the strange performance last time, I generate correlated row signals and replace the entire row at the specific position in the non-signal matrix.\
The settings are: $\lambda_i \sim \text{lognormal}(\Lambda,\Sigma)$ where $\Sigma = \text{diag}(\sigma_1,...,\sigma_{J-1})P\text{diag}(\sigma_1,...,\sigma_{J-1})$ and $P$ is the correlation matrix.\
(1) correlated row signals have equal mean: $\Lambda = (\lambda_0, ... ,\lambda_0)$\
(2) correlated row signals have different ratio of $\lambda_0$: $\Lambda = (\lambda_0, \lambda_0, 1.2\lambda_0, 1.2\lambda_0, 1.5\lambda_0, 1.5\lambda_0)$

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(plotly)
library(ggplot2)

```

## Equal mean

```{r echo=FALSE, message=FALSE, warning=FALSE}
simu_df_final <- readRDS("D:/Documents/UB/Research/Code/CCR/Download/row_signal_quantile_20231023.RDS")

plot_metrics <- function(metric = NULL,
                         lwd = 1.2){

  simu_df_final %>%
    {if (is.null(metric)) {.}
      else {filter( ., measures %in% metric )}} %>%
    ggplot(
      aes(x = lambda,
          y = value,
          colour = model
      ), size = 2
    ) +
    facet_wrap( ~measures ) +
    ylim(0,1) +
    geom_line(size = lwd) +
    scale_color_manual(
      values = c(
        "LRT" = "black",
        "poisson" = "blue1",
        "poisson_indep" = "lightskyblue2",
        "zip" = "yellow1",
        "zip_indep" = "orange1"
      )
    ) +
    geom_hline(yintercept = 0.05,
               lty = "dashed",
               color = "red",
               linewidth = lwd) +
    annotate(geom="text",
             x=4.1,
             y=0.07,
             label="0.05",
             color="red") +
    theme(
      legend.position = "top"
    )

}

plot_metrics() 

```

## Different means

```{r echo=FALSE, message=FALSE, warning=FALSE}
simu_df_final <- readRDS("D:/Documents/UB/Research/Code/CCR/Download/row_signal_diff_quantile_20231023.RDS")

plot_metrics <- function(metric = NULL,
                         lwd = 1.2){

  simu_df_final %>%
    {if (is.null(metric)) {.}
      else {filter( ., measures %in% metric )}} %>%
    ggplot(
      aes(x = lambda,
          y = value,
          colour = model
      ), size = 2
    ) +
    facet_wrap( ~measures ) +
    ylim(0,1) +
    geom_line(size = lwd) +
    scale_color_manual(
      values = c(
        "LRT" = "black",
        "poisson" = "blue1",
        "poisson_indep" = "lightskyblue2",
        "zip" = "yellow1",
        "zip_indep" = "orange1"
      )
    ) +
    geom_hline(yintercept = 0.05,
               lty = "dashed",
               color = "red",
               linewidth = lwd) +
    annotate(geom="text",
             x=4.1,
             y=0.07,
             label="0.05",
             color="red") +
    theme(
      legend.position = "top"
    )

}

plot_metrics() 
```

In these two cases, FDRs are not controlled to be around 0.05 but 0.25, and Levels are all very high which means too many false discoveries. To avoid programming problem, I redid the no correlation row signal example using the new data generation method. 

## No correlataion row signal

```{r echo=FALSE, message=FALSE, warning=FALSE}
simu_df_final <- readRDS("D:/Documents/UB/Research/Code/CCR/Download/row_signal_quantile_20231024.RDS")

plot_metrics <- function(metric = NULL,
                         lwd = 1.2){

  simu_df_final %>%
    {if (is.null(metric)) {.}
      else {filter( ., measures %in% metric )}} %>%
    ggplot(
      aes(x = lambda,
          y = value,
          colour = model
      ), size = 2
    ) +
    facet_wrap( ~measures ) +
    ylim(0,1) +
    geom_line(size = lwd) +
    scale_color_manual(
      values = c(
        "LRT" = "black",
        "poisson" = "blue1",
        "poisson_indep" = "lightskyblue2",
        "zip" = "yellow1",
        "zip_indep" = "orange1"
      )
    ) +
    geom_hline(yintercept = 0.05,
               lty = "dashed",
               color = "red",
               linewidth = lwd) +
    annotate(geom="text",
             x=4.1,
             y=0.07,
             label="0.05",
             color="red") +
    theme(
      legend.position = "top"
    )

}

plot_metrics() 
```

In this case, FDR is controlled around 0.05 and levels for all models make more sense. It means the calculation of the metrics should be correct. The result of pvLRT shows that the data generation process should be also correct.

pvBayes doesn't have better performance than pvLRT as our expected under correlated signals. I think the problem comes from the correlation. I worked on some samples and checked the MCMC sampling should have no problem. I saw some false discoveries has relatively large test statistics, just 0.01 or 0.02 greater than the threshold. I am doing more research on these samples. 

If you have any suggestions that I can do before Friday, I would appreciate it.



